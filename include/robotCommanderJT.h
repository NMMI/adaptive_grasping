#ifndef ROBOT_COMMANDER_JT_H
#define ROBOT_COMMANDER_JT_H

#include <mutex>
#include <vector>
#include <array>
#include <boost/scoped_ptr.hpp>
#include <Eigen/Dense>
#include <sensor_msgs/JointState.h>
#include <trajectory_msgs/JointTrajectory.h>
#include <kdl/jacobian.hpp>
#include <kdl/jntarray.hpp>
#include <kdl_parser/kdl_parser.hpp>
#include <kdl/chainjnttojacsolver.hpp>
#include <urdf/model.h>
#include <utils/pseudo_inversion.h>
#include <ros/subscribe_options.h>
#include "ros/ros.h"

// Action Client
#include <actionlib/client/simple_action_client.h>
#include <actionlib/client/terminal_state.h>
#include <control_msgs/FollowJointTrajectoryAction.h>

// Service Includes
#include "adaptive_grasping/velCommand.h"


/**
* @brief This class is called by the adaptive_grasping method to close the
* hand and move the kuka in order to execute the references generated by the
* contactPreserver according to the adaptive_grasping algorithm.
* @uses joint trajectory controller for the hand
* @uses joint trajectory controller for the kuka arm (palm)
*
*/

namespace adaptive_grasping {

  class robotCommanderJT {

  public:

    /** CONSTRUCTOR
    * @brief Default constructor for robotCommander
    *
    * @param hand_topic_
    *   the topic for commanding the hand closure
    * @param arm_topic_
    *   the topic for commanding the arm
    * @return null
    */
    robotCommanderJT(std::string hand_topic_, std::string arm_topic_,
      std::vector<std::string> joint_names_vec_, ros::Duration header_dur_, 
      ros::Duration exec_wait_dur_, ros::Duration dt_);

    /** DESTRUCTOR
    * @brief Default destructor for robotCommander
    *
    * @param null
    * @return null
    */
    ~robotCommanderJT();

  private:

    // Basic variables
    ros::NodeHandle nh_rc;
    ros::Subscriber joint_state_sub;    // For getting hand joint states
    ros::ServiceServer rc_jt_server;    // For getting velocity requests and sending trajectory to robot
    ros::Time prev_time;
    ros::Time curr_time;
    ros::Duration header_dur;           // For the headers of the trajectories
    ros::Duration exec_wait_dur;        // For waiting for result of joint traj controllers
    ros::Duration dt;                   // Used to integrate hand joint speed

    // A mutual exclusion lock for the variables of this class
    std::mutex robot_commander_mutex;

    // A data structure containing the names of the hand joints in order
    std::vector<std::string> joint_names_vec;

    // The topic names for hand commanding and arm commanding
    std::string hand_topic;
    std::string arm_topic;

    // The commanded values given by contactPreserver (where service msg is saved)
    Eigen::VectorXd x_ref;

    // A sensor message and an Eigen vector containing the latest available joints of the hand
    sensor_msgs::JointState::ConstPtr full_joint_state;
    Eigen::VectorXd current_joints_vector;

    // Action clients for the hand and the arm
    std::shared_ptr<actionlib::SimpleActionClient<control_msgs::FollowJointTrajectoryAction>> arm_client;
    std::shared_ptr<actionlib::SimpleActionClient<control_msgs::FollowJointTrajectoryAction>> hand_client;

    // The control messages for arm and hand (uses trajectories below)
    control_msgs::FollowJointTrajectoryGoal arm_goalmsg;
    control_msgs::FollowJointTrajectoryGoal hand_goalmsg;

    // The trajectories for hand and arm (useds point below)
    trajectory_msgs::JointTrajectory arm_traj;
    trajectory_msgs::JointTrajectory hand_traj;

    // The temporary variable for creating traj points for both the hand and the arm
    trajectory_msgs::JointTrajectoryPoint tmp_point;

    // KDL and Eigen variables used for inverse diff kinematics
    KDL::Tree robot_kin_tree;
    KDL::Chain robot_kin_chain;
    KDL::Jacobian arm_jac;
    KDL::JntArray arm_js;
    boost::scoped_ptr<KDL::ChainJntToJacSolver> jnt_to_jac_solver;
    Eigen::MatrixXd arm_jac_pinv;

    // The joint velocities to be executed on robot
    Eigen::VectorXd q_dot_arm;
    float q_dot_hand;

    // URDF model and joints
    urdf::Model urdf;
    urdf::JointConstSharedPtr urdf_joint;

    // A structure for saving joint limits
    struct limits_ {
        KDL::JntArray min;
        KDL::JntArray max;
        KDL::JntArray velocity;
    } joint_limits;

    /** GETJOINTSTATES
    * @brief Private callback function to get and write joint states of the hand
    *
    * @param null
    * @return null
    */
    void getJointStates(const sensor_msgs::JointStateConstPtr& msg);

    /** EXTRACTJOINTS
    * @brief Private function to write the needed joint states to a vector
    *
    * @param msg
    * @return Eigen::VectorXd contains kuka's and hand joints in order
    */
    Eigen::VectorXd extractJoints();

    /** SETKDL
    * @brief Private function to set all KDL elements for doing inverse kinematics
    *
    * @param null
    * @return bool success
    */
    bool setKDL();

    /** PERFORMROBOTCOMMAND
    * @brief Private callback function of the main service of robotCommander
    *
    * @param req
    * @param res
    * @return null
    */
    bool performRobotCommand(adaptive_grasping::velCommand::Request &req,
        adaptive_grasping::velCommand::Response &res);
    
    /** INTEGRATEANDEXECUTE
    * @brief    Private function to integrate the joint velocities and execute through
    *           joint trajectory controller
    *
    * @param null
    * @return bool success
    */
    bool integrateAndExecute();

  };

}


#endif // ROBOT_COMMANDER_JT_H
